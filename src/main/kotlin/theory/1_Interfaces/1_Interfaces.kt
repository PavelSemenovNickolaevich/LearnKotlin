


/*

Интерфейс - описывает поведение (контракт) для определенного типа объекта.
Этот контракт класс обязан реализовать.
Можно обязать класс иметь определенные свойства и метода (исходя из бизнес задач)


Класс может реализоваться любое количество интерфейсов, но наследоваться только от одного класса.

В Kotlin интерфейсе можем указывать не только функции, но и свойства объекта (переменные/константы) - чтобы обязать все классы-реализации иметь их.
В Java интерфейсе нет такой возможности, поэтому приходилось идти обходным путем - описывать методы get или set (чтобы обязать объект иметь какое-либо свойство)


Интерфейс:
- все его функции, переменные, константы - всегда open (как и в Java все элементы интерфейсы автоматически public), поэтому не нужно дописывать
- можно описывать функции с реализацией (аналог default методов в Java интерфейсах)
- нельзя переопределять внутри интерфейса функции toString, equals, hashCode из объекта Any


 */




// правой кнопкой -> Run
// можете комментировать определенные строки функции и заново запускать проект, чтобы не запутаться при выводе результатов
fun main() {
    var macBook = MacBook("mac", 50, "1111", "super model")
    macBook.name = "new book" // задаем новое значение name
    macBook.beep()


    var samsungComp = SamsungComp()
    samsungComp.name = "samsung" // можем изменять значение в любое время
    samsungComp.beep()


}


// интерфейс и все его функции, переменные, константы - всегда open
interface IComputer { // нажимайте слева возле номера строки, где зеленый кружок и стрелка вниз (в IDEA) - чтобы увидеть все классы-реализации интерфейса

    // СВОЙСТВА (будем обязаны иметь их во всех классах-реализациях)

    var name: String // переменная - нельзя задавать значение, т.к. это интерфейс (абстракция)

    val weight: Int // константа без начального значения (должно задаваться в классах реализациях)

    // для констант можно задавать значения сразу в интерфейсе
    val code
        get() = "01010101"


    // ФУНКЦИИ (будем обязаны иметь их во всех классах-реализациях)

    fun beep() // функция без дефолтной реализации


}


/*

Класс, реализующий интерфейс(ы)

компилятор обязывает реализовать:
- свойства (с помощью ПК или get/set)
- функции интерфейсов


В Java нужны ключевые слова:
extends
implements


 */
class MacBook(override var name: String, override val weight: Int, override val code: String, var model: String) : IComputer { // интерфейсы можно перечислять через запятую
    // для всех свойств, которые мы реализовываем из интерфейсы - мы обязаны указать слово override


    override fun beep() {
        println("$model $name beep")
    }
}


/*

Класс, реализующий интерфейс(ы)

компилятор обязывает реализовать:
- свойства (с помощью ПК или get/set)
- функции интерфейсов

 */

class SamsungComp : IComputer { // для реализации интерфеса просто пишем символ ":"  , не нужно писать implements как в Java


    // реализуем свойства интерфейса с помощью геттеров/сеттеров (получается много излишнего кода, по сравнению с вариантом ПК выше)

    override var name: String = ""
        get() = field // field означает текущее свойство name
        set(value) {
            field = value
        } // value - новое значение

    // override нужен для того, чтобы указать, что мы реализовываем переменную/константу из интерфейса (иначе компилятор будет ругаться, что не все реализовали)
    override val weight = 20 // константа


    override fun beep() {
        println("$code beep")
    }

}






